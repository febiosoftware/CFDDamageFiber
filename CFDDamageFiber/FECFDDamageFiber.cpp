/*Generated by FEBio Studio 3.0.0*/

#include "FECFDDamageFiber.h"
#include <FEBioMech/FEFiberIntegrationTriangle.h>
#include <FEBioMech/FEFiberDensityDistribution.h>


FECFDDamageFiber::Point::Point() : FEFiberMaterialPoint(nullptr)
{
}

void FECFDDamageFiber::Point::Init()
{
	FEFiberMaterialPoint::Init();
}

void FECFDDamageFiber::Point::Update(const FETimeInfo& ti)
{
	m_Dp = m_D;
}

//====================================================================================
BEGIN_FECORE_CLASS(FEDeltaDamageCDF, FEDamageCDF)
	ADD_PARAMETER(m_mu, "mu");
END_FECORE_CLASS();

FEDeltaDamageCDF::FEDeltaDamageCDF(FEModel* fem) : FEDamageCDF(fem) 
{
	m_mu = 0.5;
}

//====================================================================================
BEGIN_FECORE_CLASS(FECFDDamageFiber, FEFiberMaterial)
	ADD_PROPERTY(m_fiber, "fiber");
	ADD_PROPERTY(m_criterion, "criterion");
	ADD_PROPERTY(m_cdf, "cdf");
END_FECORE_CLASS();

FECFDDamageFiber::FECFDDamageFiber(FEModel* fem) : FEFiberMaterial(fem)
{
	m_fiber = nullptr;
	m_criterion = nullptr;
	m_cdf = nullptr;
}

FECFDDamageFiber::~FECFDDamageFiber()
{

}

bool FECFDDamageFiber::Init()
{
	if (FEFiberMaterial::Init() == false) return false;

	// get the parent material
	FEMaterial* parent = dynamic_cast<FEMaterial*>(GetParent());
	if (parent == nullptr) return false;

	// get the integration rule
	FEFiberIntegrationTriangle* rule = dynamic_cast<FEFiberIntegrationTriangle*>(parent->ExtractProperty<FEFiberIntegrationTriangle>());
	if (rule == nullptr) return false;

	return m_fiber->Init();
}

bool FECFDDamageFiber::Validate()
{
	if (FEFiberMaterial::Validate() == false) return false;

	// get the parent material
	FEMaterial* parent = dynamic_cast<FEMaterial*>(GetParent());
	if (parent == nullptr) return false;

	// get the integration rule
	m_rule = dynamic_cast<FEFiberIntegrationTriangle*>(parent->ExtractProperty<FEFiberIntegrationTriangle>());
	if (m_rule == nullptr) return false;

	m_R = dynamic_cast<FEFiberDensityDistribution*>(parent->ExtractProperty<FEFiberDensityDistribution>());
	if (m_R == nullptr) return false;

	assert(m_rule->m_nres >= 0);

	return m_fiber->Validate();
}

FEMaterialPointData* FECFDDamageFiber::CreateMaterialPointData()
{
	return new FECFDDamageFiber::Point();
}

mat3ds FECFDDamageFiber::FiberStress(FEMaterialPoint& mp, const vec3d& a0)
{
	FEElasticMaterialPoint& ep = *mp.ExtractData<FEElasticMaterialPoint>();
	FECFDDamageFiber::Point& fp = *mp.ExtractData<FECFDDamageFiber::Point>();

	double val = m_criterion->Criterion(mp, a0);
	double D = m_cdf->cdf(mp, val);
	if (D != 0)
	{
		if (fp.m_D.empty())
		{
			fp.m_D.resize(m_rule->m_nres, 0.0);
			fp.m_Dp.resize(m_rule->m_nres, 0.0);
		}

		assert((fp.m_index >= 0) && (fp.m_index < fp.m_D.size()));
		double Dn = fp.m_Dp[fp.m_index];
		if (D > Dn) fp.m_D[fp.m_index] = D;
		D = Dn;
	}
	else if (!fp.m_D.empty())
	{
		assert((fp.m_index >= 0) && (fp.m_index < fp.m_D.size()));
		D = fp.m_D[fp.m_index];
	}
	return (1 - D)*m_fiber->FiberStress(mp, a0);
}

tens4ds FECFDDamageFiber::FiberTangent(FEMaterialPoint& mp, const vec3d& a0)
{
	FECFDDamageFiber::Point& fp = *mp.ExtractData<FECFDDamageFiber::Point>();

	double D = 0.0;
	if (!fp.m_D.empty())
	{
		assert((fp.m_index >= 0) && (fp.m_index < fp.m_D.size()));
		D = fp.m_D[fp.m_index];
	}

	return (1 - D)*m_fiber->FiberTangent(mp, a0);
}

double FECFDDamageFiber::FiberStrainEnergyDensity(FEMaterialPoint& mp, const vec3d& a0)
{
	FECFDDamageFiber::Point& fp = *mp.ExtractData<FECFDDamageFiber::Point>();

	double D = 0.0;
	if (!fp.m_D.empty())
	{
		assert((fp.m_index >= 0) && (fp.m_index < fp.m_D.size()));
		D = fp.m_D[fp.m_index];
	}

	return (1 - D)*m_fiber->FiberStrainEnergyDensity(mp, a0);
}

double FECFDDamageFiber::CumulativeDamage(FEMaterialPoint& mp)
{
	FECFDDamageFiber::Point& fp = *mp.ExtractData<FECFDDamageFiber::Point>();

	vector<double>& D = fp.m_D;
	if (D.empty()) return 0;

	if (m_R == nullptr) return 0.0;

	FEFiberIntegrationSchemeIterator* it = m_rule->GetIterator(&mp);
	int i = 0;
	double avg = 0;
	double Rsum = 0;
	if (it->IsValid())
	{
		do {
			vec3d& N = it->m_fiber;
			double R = m_R->FiberDensity(mp, N);
			Rsum += R*it->m_weight;
			avg += R * D[i++] * it->m_weight;
		}
		while (it->Next());
		assert(i == D.size());
		avg /= Rsum;
	}

	return avg;
}
